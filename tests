import numpy as np
import matplotlib.pyplot as plt

# === КЛАССЫ ===
class Element:
    def __init__(self, name, length=0.0):
        self.name = name
        self.length = length
    
    def matrix(self):
        raise NotImplementedError
    
    def track_sigma(self, sigma_in):
        """Пропагация матрицы ковариации: Σ_out = M · Σ_in · M^T"""
        M = self.matrix()
        return M @ sigma_in @ M.T

class Drift(Element):
    def __init__(self, L):
        super().__init__(f"Drift_{L:.2f}", L)
        self.L = L
    
    def matrix(self):
        return np.array([[1, self.L], 
                         [0, 1]])

class Quadrupole(Element):
    def __init__(self, f, length=0.0, name="Quad"):
        super().__init__(name, length)
        self.f = f
    
    def matrix(self):
        return np.array([[1, 0], 
                         [-1/self.f, 1]])

class Beamline:
    def __init__(self):
        self.elements = []
    
    def add(self, element):
        self.elements.append(element)
        return self
    
    def track_sigma_along(self, sigma0):
        """
        Возвращает историю Σ вдоль решетки
        """
        sigma = sigma0.copy()
        s_pos = 0
        
        s_history = [0]
        sigma_history = [sigma.copy()]  # ← Сохраняем полную матрицу Σ!
        
        for elem in self.elements:
            sigma = elem.track_sigma(sigma)
            s_pos += elem.length
            
            s_history.append(s_pos)
            sigma_history.append(sigma.copy())
        
        return np.array(s_history), sigma_history
    
    def get_emittance(self, sigma):
        """Эмиттанс = sqrt(det(Σ))"""
        return np.sqrt(np.linalg.det(sigma))
    
    def extract_twiss(self, sigma, epsilon):
        """Извлекает α, β, γ из матрицы Σ"""
        beta = sigma[0, 0] / epsilon
        alpha = -sigma[0, 1] / epsilon
        gamma = sigma[1, 1] / epsilon
        return beta, alpha, gamma

# === ФУНКЦИИ ===
def make_sigma_from_twiss(beta0, alpha0, epsilon):
    """Создаёт матрицу ковариации из параметров Твисса"""
    gamma0 = (1 + alpha0**2) / beta0
    sigma = epsilon * np.array([[beta0, -alpha0], 
                                [-alpha0, gamma0]])
    return sigma

# === СИМУЛЯЦИЯ ===
if __name__ == "__main__":
    # Настройки
    EPSILON = 1e-6      # Эмиттанс [м·рад]
    BETA0 = 10.0        # Начальная β-функция [м]
    ALPHA0 = 0.0        # Начальный α (пучок в "талии")
    
    # Создаём начальную Σ-матрицу
    sigma0 = make_sigma_from_twiss(BETA0, ALPHA0, EPSILON)
    print(f"Начальный эмиттанс: {np.sqrt(np.linalg.det(sigma0)):.2e}")
    
    # Сборка решетки (FODO)
    bl = Beamline()
    bl.add(Quadrupole(f=5.0, name="QF"))
    bl.add(Drift(2.0))
    bl.add(Quadrupole(f=-5.0, name="QD"))
    bl.add(Drift(2.0))
    bl.add(Quadrupole(f=5.0, name="QF"))
    
    # Трассировка Σ
    s, sigma_history = bl.track_sigma_along(sigma0)
    
    # Извлекаем параметры Твисса из истории
    beta = []
    alpha = []
    gamma = []
    emittance_list = []
    
    for sigma in sigma_history:
        b, a, g = bl.extract_twiss(sigma, EPSILON)
        beta.append(b)
        alpha.append(a)
        gamma.append(g)
        emittance_list.append(bl.get_emittance(sigma))
    
    beta = np.array(beta)
    alpha = np.array(alpha)
    gamma = np.array(gamma)
    emittance_list = np.array(emittance_list)
    
    # === ПРОВЕРКА ИНВАРИАНТА ===
    print(f"\nЭмиттанс в начале: {emittance_list[0]:.2e}")
    print(f"Эмиттанс в конце:   {emittance_list[-1]:.2e}")
    print(f"Изменение:          {(emittance_list[-1] - emittance_list[0]) / emittance_list[0] * 100:.2e} %")
    
    # === ВИЗУАЛИЗАЦИЯ β-функции ===
    plt.figure(figsize=(10, 5))
    plt.plot(s, beta, 'b-', linewidth=2, label='β(s) [м]')
    plt.fill_between(s, 0, beta, alpha=0.3, color='blue')
    
    # Маркеры квадруполей
    s_marker = 0
    for i, elem in enumerate(bl.elements):
        if isinstance(elem, Quadrupole):
            color = 'red' if elem.f > 0 else 'green'
            label = elem.name if i == 0 else ""
            plt.axvline(s_marker, color=color, linestyle='--', alpha=0.5, label=label)
        s_marker += elem.length
    
    plt.xlabel('Path s [м]')
    plt.ylabel('β(s) [м]')
    plt.title('Beta Function Along FODO Lattice')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig('day3_beta_function.png', dpi=150)
    plt.show()
    
    # === ВИЗУАЛИЗАЦИЯ эмиттанса (должен быть константой) ===
    plt.figure(figsize=(8, 4))
    plt.plot(s, emittance_list, 'r-', linewidth=2)
    plt.axhline(EPSILON, color='gray', linestyle='--', alpha=0.5, label='Expected ε')
    plt.xlabel('Path s [м]')
    plt.ylabel('Emittance [м·рад]')
    plt.title('Emittance Conservation Check')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig('day3_emittance.png', dpi=150)
    plt.show()
    
    # === ФАЗОВЫЙ ПОРТРЕТ ===
    theta = np.linspace(0, 2*np.pi, 100)
    x_ellipse = np.sqrt(EPSILON * beta[0]) * np.cos(theta)
    xp_ellipse = -np.sqrt(EPSILON / beta[0]) * (alpha[0] * np.cos(theta) + np.sin(theta))
    
    plt.figure(figsize=(5, 5))
    plt.plot(x_ellipse*1000, xp_ellipse*1000, 'b-', linewidth=2)
    plt.fill(x_ellipse*1000, xp_ellipse*1000, alpha=0.3, color='blue')
    plt.xlabel('x [мм]')
    plt.ylabel("x' [мрад]")
    plt.title('Phase Space Ellipse (Twiss)')
    plt.grid(True, alpha=0.3)
    plt.axis('equal')
    plt.tight_layout()
    plt.savefig('day3_phase_space.png', dpi=150)
    plt.show()